<!DOCTYPE html>
<meta charset="utf-8">

<head>

<title>D3-Labeler</title>

<style>

body {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.circ {
  stroke: #000;
}

.rect {
  stroke: #000;
}

.label {
  font: 14px sans-serif;
}

.link { 
    stroke:gray;
    stroke-width:0.5
}

h2 { 
    font-size: 22px;
}

div {
    margin-top:35px;
    margin-bottom:0px;
    margin-left:150px;
}

p {
    font-family: sans-serif;
    font-size: 14px;
}

</style>
</head>

<body>

<div>

<h2>D3-Labeler</h2>
<p>A D3 plug-in for automatic label placement using simulated annealing that easily incorporates into existing D3 code, with <br> syntax mirroring other D3 layouts.</p>

<form>
Number of labels: <input type="text" id="n_labels" value=50 size="6"> &nbsp;&nbsp;|&nbsp;&nbsp;
<input type="radio" name="dist" id="uniform" value="Uniform" checked="checked">Uniform&nbsp;&nbsp;<input type="radio" name="dist" id="gaussian" value="Gaussian">Gaussian&nbsp;&nbsp;|&nbsp;&nbsp; 
Number of MC sweeps: <input type="text" id="n_sweeps" value=1000 size="6"> &nbsp;&nbsp;|&nbsp;&nbsp;
<button type="button" id="start">Label</button>
</form> 

</div>

<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>

    // labeler.js
    (function() {

    d3.labeler = function() {
      var lab = [],
          anc = [],
          w = 1, // box width
          h = 1, // box width
          labeler = {};

      var max_move = 5.0,
          max_angle = 0.5,
          acc = 0;
          rej = 0;

      // weights
      var w_len = 0.2, // leader line length 
          w_inter = 1.0, // leader line intersection
          w_lab2 = 30.0, // label-label overlap
          w_lab_anc = 30.0; // label-anchor overlap
          w_orient = 3.0; // orientation bias

      // booleans for user defined functions
      var user_energy = false,
          user_schedule = false;

      var user_defined_energy, 
          user_defined_schedule;

      energy = function(index) {
      // energy function, tailored for label placement

          var m = lab.length, 
              ener = 0,
              dx = lab[index].x - anc[index].x,
              dy = anc[index].y - lab[index].y,
              dist = Math.sqrt(dx * dx + dy * dy),
              overlap = true,
              amount = 0
              theta = 0;

          // penalty for length of leader line
          if (dist > 0) ener += dist * w_len;

          // label orientation bias
          dx /= dist;
          dy /= dist;
          if (dx > 0 && dy > 0) { ener += 0 * w_orient; }
          else if (dx < 0 && dy > 0) { ener += 1 * w_orient; }
          else if (dx < 0 && dy < 0) { ener += 2 * w_orient; }
          else { ener += 3 * w_orient; }

          var x21 = lab[index].x,
              y21 = lab[index].y - lab[index].height + 2.0,
              x22 = lab[index].x + lab[index].width,
              y22 = lab[index].y + 2.0;
          var x11, x12, y11, y12, x_overlap, y_overlap, overlap_area;

          for (var i = 0; i < m; i++) {
            if (i != index) {

              // penalty for intersection of leader lines
              overlap = intersect(anc[index].x, lab[index].x, anc[i].x, lab[i].x,
                              anc[index].y, lab[index].y, anc[i].y, lab[i].y);
              if (overlap) ener += w_inter;

              // penalty for label-label overlap
              x11 = lab[i].x;
              y11 = lab[i].y - lab[i].height + 2.0;
              x12 = lab[i].x + lab[i].width;
              y12 = lab[i].y + 2.0;
              x_overlap = Math.max(0, Math.min(x12,x22) - Math.max(x11,x21));
              y_overlap = Math.max(0, Math.min(y12,y22) - Math.max(y11,y21));
              overlap_area = x_overlap * y_overlap;
              ener += (overlap_area * w_lab2);
              }

              // penalty for label-anchor overlap
              x11 = anc[i].x - anc[i].r;
              y11 = anc[i].y - anc[i].r;
              x12 = anc[i].x + anc[i].r;
              y12 = anc[i].y + anc[i].r;
              x_overlap = Math.max(0, Math.min(x12,x22) - Math.max(x11,x21));
              y_overlap = Math.max(0, Math.min(y12,y22) - Math.max(y11,y21));
              overlap_area = x_overlap * y_overlap;
              ener += (overlap_area * w_lab_anc);

          }
          return ener;
      };

      mcmove = function(currT) {
      // Monte Carlo translation move

          // select a random label
          var i = Math.floor(Math.random() * lab.length); 

          // save old coordinates
          var x_old = lab[i].x;
          var y_old = lab[i].y;

          // old energy
          var old_energy;
          if (user_energy) {old_energy = user_defined_energy(i, lab, anc)}
          else {old_energy = energy(i)}

          // random translation
          lab[i].x += (Math.random() - 0.5) * max_move;
          lab[i].y += (Math.random() - 0.5) * max_move;

          // hard wall boundaries
          if (lab[i].x > w) lab[i].x = x_old;
          if (lab[i].x < 0) lab[i].x = x_old;
          if (lab[i].y > h) lab[i].y = y_old;
          if (lab[i].y < 0) lab[i].y = y_old;

          // new energy
          var new_energy;
          if (user_energy) {new_energy = user_defined_energy(i, lab, anc)}
          else {new_energy = energy(i)}

          // delta E
          var delta_energy = new_energy - old_energy;

          if (Math.random() < Math.exp(-delta_energy / currT)) {
            acc += 1;
          } else {
            // move back to old coordinates
            lab[i].x = x_old;
            lab[i].y = y_old;
            rej += 1;
          }

      };

      mcrotate = function(currT) {
      // Monte Carlo rotation move

          // select a random label
          var i = Math.floor(Math.random() * lab.length); 

          // save old coordinates
          var x_old = lab[i].x;
          var y_old = lab[i].y;

          // old energy
          var old_energy;
          if (user_energy) {old_energy = user_defined_energy(i, lab, anc)}
          else {old_energy = energy(i)}

          // random angle
          var angle = (Math.random() - 0.5) * max_angle;

          var s = Math.sin(angle);
          var c = Math.cos(angle);

          // translate label (relative to anchor at origin):
          lab[i].x -= anc[i].x
          lab[i].y -= anc[i].y

          // rotate label
          var x_new = lab[i].x * c - lab[i].y * s,
              y_new = lab[i].x * s + lab[i].y * c;

          // translate label back
          lab[i].x = x_new + anc[i].x
          lab[i].y = y_new + anc[i].y

          // hard wall boundaries
          if (lab[i].x > w) lab[i].x = x_old;
          if (lab[i].x < 0) lab[i].x = x_old;
          if (lab[i].y > h) lab[i].y = y_old;
          if (lab[i].y < 0) lab[i].y = y_old;

          // new energy
          var new_energy;
          if (user_energy) {new_energy = user_defined_energy(i, lab, anc)}
          else {new_energy = energy(i)}

          // delta E
          var delta_energy = new_energy - old_energy;

          if (Math.random() < Math.exp(-delta_energy / currT)) {
            acc += 1;
          } else {
            // move back to old coordinates
            lab[i].x = x_old;
            lab[i].y = y_old;
            rej += 1;
          }
          
      };

      intersect = function(x1, x2, x3, x4, y1, y2, y3, y4) {
      // returns true if two lines intersect, else false
      // from http://paulbourke.net/geometry/lineline2d/

        var mua, mub;
        var denom, numera, numerb;

        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        numera = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        numerb = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);

        /* Is the intersection along the the segments */
        mua = numera / denom;
        mub = numerb / denom;
        if (!(mua < 0 || mua > 1 || mub < 0 || mub > 1)) {
            return true;
        }
        return false;
      }

      cooling_schedule = function(currT, initialT, nsweeps) {
      // linear cooling
        return (currT - (initialT / nsweeps));
      }

      labeler.start = function(nsweeps) {
      // main simulated annealing function
          var m = lab.length,
              currT = 1.0,
              initialT = 1.0;

          for (var i = 0; i < nsweeps; i++) {
            for (var j = 0; j < m; j++) { 
              if (Math.random() < 0.5) { mcmove(currT); }
              else { mcrotate(currT); }
            }
            currT = cooling_schedule(currT, initialT, nsweeps);
          }
      };

      labeler.width = function(x) {
      // users insert graph width
        if (!arguments.length) return w;
        w = x;
        return labeler;
      };

      labeler.height = function(x) {
      // users insert graph height
        if (!arguments.length) return h;
        h = x;    
        return labeler;
      };

      labeler.label = function(x) {
      // users insert label positions
        if (!arguments.length) return lab;
        lab = x;
        return labeler;
      };

      labeler.anchor = function(x) {
      // users insert anchor positions
        if (!arguments.length) return anc;
        anc = x;
        return labeler;
      };

      labeler.alt_energy = function(x) {
      // user defined energy
        if (!arguments.length) return energy;
        user_defined_energy = x;
        user_energy = true;
        return labeler;
      };

      labeler.alt_schedule = function(x) {
      // user defined cooling_schedule
        if (!arguments.length) return  cooling_schedule;
        user_defined_schedule = x;
        user_schedule = true;
        return labeler;
      };

      return labeler;
    };

    })();

    // Global variables
    var anchor_array = [],
        label_array = [],
        margin = {top: 20, right: 300, bottom: 60, left: 150},
        width = 1240 - margin.left - margin.right,
        height = 530 - margin.top - margin.bottom,
        x_mean = width/2,
        y_mean = height/2,
        offset = 4,
        radius = 7;

    var anchor_data, labels, circ, links, bounds;

    // Setup canvas
    var svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Draw boundaries of figure
    var plot_boundary = svg.append("rect")
            .attr("x", 0.0)
            .attr("y", 0.0)
            .attr("width", width)
            .attr("height", height)
            .style("fill-opacity", '0.0')
            .style("stroke", "black")
            .style("stroke-opacity", "0.4");


    // Functions

    function gaussian() {
        // Box-Muller transformation
        do
        {
            u = 2 * Math.random() - 1;
            v = 2 * Math.random() - 1;
            r = u * u + v * v;
        }
        while (r >= 1.0);

        var c = Math.sqrt(-2 * Math.log(r) / r );
        return u * c;
    }

    function redrawLabels() {
        // Redraw labels and leader lines

        labels
        .transition()
        .duration(800)
        .attr("x", function(d) { return (d.x); })
        .attr("y", function(d) { return (d.y); });

        links
        .transition()
        .duration(800)
        .attr("x2",function(d) { return (d.x); })
        .attr("y2",function(d) { return (d.y); });
    }

    function randomize(count, is_uniform) {
        anchor_array = [];
        label_array = [];

        for (var i = 0; i < count; i++) {
            
            var xval, yval;

            if (is_uniform) {
                // Uniformly distributed of x, y
                do {
                    xval=Math.random() * width;
                } while (xval < 10 || xval > width - 60);

                do {
                    yval=Math.random() * width;
                } while (yval < 28 || yval > height - 15);

            } else {
                // Gaussian distributed x, y
                do {
                    xval = x_mean + gaussian() * width / 6;
                } while (xval < 10 || xval > width - 60);

                do {
                    yval = y_mean + gaussian() * height / 6;
                } while (yval < 28 || yval > height - 15);

            }

            // Put label and anchor positions into arrays
            anchor_array.push({x: xval, y: yval, r: radius});
            label_array.push({x: xval, y: yval, name: "Node "+String(i), width: 0.0, height: 0.0});
        }

        // Delete old stuff
        svg.selectAll(".dot").data([]).exit().remove();
        svg.selectAll(".label").data([]).exit().remove();
        svg.selectAll(".circ").data([]).exit().remove();
        svg.selectAll(".link").data([]).exit().remove();
        svg.selectAll(".rect").data([]).exit().remove();

        // Draw anchors
        anchors = svg.selectAll(".dot")
            .data(anchor_array)
            .enter().append("circle")
            .attr("class", "dot")
            .attr("r", function(d) { return (d.r); })
            .attr("cx", function(d) { return (d.x); })
            .attr("cy", function(d) { return (d.y); })
            .style("fill", 'green');

        // Draw labels
        labels = svg.selectAll(".label")
            .data(label_array)
            .enter()
            .append("text")
            .attr("class", "label")
            .attr('text-anchor', 'start')
            .text(function(d) { return d.name; })
            .attr("x", function(d) { return (d.x); })
            .attr("y", function(d) { return (d.y); })
            .attr("fill", "black");

        // Size of each label
        var index = 0;
        labels.each(function() {
            label_array[index].width = this.getBBox().width;
            label_array[index].height = this.getBBox().height;
            index += 1;
        });

        // Draw data points
        circ = svg.selectAll(".circ")
            .data(label_array)
            .enter().append("circle")
            .attr("class", ".circ")
            .attr("r", 20.0)
            .attr("cx", function(d) { return (d.x); })
            .attr("cy", function(d) { return (d.y - offset); })
            .style("fill", 'red')
            .attr('opacity',0.0);

        // Draw links
        links = svg.selectAll(".link")
            .data(label_array)
            .enter()
            .append("line")
            .attr("class", "link")
            .attr("x1", function(d) { return (d.x); })
            .attr("y1", function(d) { return (d.y); })
            .attr("x2", function(d) { return (d.x); })
            .attr("y2", function(d) { return (d.y); })
            .attr("stroke-width", 0.6)
            .attr("stroke", "gray");
        
    };

    // Start button function
    d3.select("#start").on("click",function() {

        // Get user-defined parameters
        var nlabels = document.getElementById('n_labels').value;
        var is_uniform = document.getElementById('uniform').checked;
        var nsweeps = document.getElementById('n_sweeps').value;

        // Randomly distribute data
        randomize(nlabels, is_uniform);

        // Setup labels
        var sim_ann = d3.labeler()
            .label(label_array)
            .anchor(anchor_array)
            .width(width)
            .height(height)
            .start(nsweeps);

        // Redraw
        redrawLabels();

        });
    
    // Default starting parameters
    // 50 labels, uniformly distributed in x, y
    randomize(50, true);

    var sim_ann = d3.labeler()
            .label(label_array)
            .anchor(anchor_array)
            .width(width)
            .height(height)
            sim_ann.start(1000);
            
    redrawLabels();

</script>
